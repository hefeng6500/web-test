<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>类式继承</title>
</head>
<body>
  <script>
      /**
       * 
       * 类式继承
      */

      /*
    function SuperClass() {
      this.superValue = true;
    }
    SuperClass.prototype.getSuperValue = function () {
      console.log(this.superValue)
    }

    function SubClass(){
      this.subValue = false
    }

    SubClass.prototype = new SuperClass()
    SubClass.prototype.getSubValue= function () {
      console.log(this.subValue)
    }

    var instance = new SubClass()
    instance.getSuperValue()
    instance.getSubValue()

    console.log(instance instanceof SuperClass)
    console.log(instance instanceof SubClass)

    // 注意： 此处是将 new SuperClass() 赋值给了 SubClass.prototype，SubClass.prototype才是SuperClass的实例
    // SubClass并不是SuperClass的实例
    console.log(SubClass instanceof SuperClass)
    console.log(SubClass.prototype instanceof SuperClass)

    */


    /**
     * 特别注意： 当父类中存在引用类型的属性时，创建的实例更改子类原型从父类构造函数继承来的共有属性时，
     * 其他子类实例时共有属性也会受到影响
     * 这是类式继承的一个缺点
    */
    function SuperClass() {
      this.books = ['Javascript', 'html', 'css']
    }

    function SubClass() {}
    SubClass.prototype = new SuperClass()

    var instance1 = new SubClass()
    var instance2 = new SubClass()
    console.log(instance1.books)  // ["Javascript", "html", "css"]
    instance1.books.push('设计模式')
    console.log(instance2.books) //  ["Javascript", "html", "css", "设计模式"]






  </script>
</body>
</html>